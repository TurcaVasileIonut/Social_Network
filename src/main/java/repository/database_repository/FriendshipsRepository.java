package repository.database_repository;

import domain.Friendship;
import repository.Repository;
import utils.DataTypeConvertors;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.*;

import static java.lang.Math.min;

public class FriendshipsRepository implements Repository <ArrayList<String>, Friendship> {

    String url;
    String username;
    String password;

    /**
     * Constructor for repository manager
     * @param url - String - the url to the database where Friendships are stored
     * @param username - String - the username to connect to the database
     * @param password - String - the password to connect to the database
     */
    public FriendshipsRepository(String url, String username, String password){
        this.url = url;
        this.username = username;
        this.password = password;
    }

    /**
     * A method that parse resultSet into friendship parameters
     * @param resultSet - ResultSet - the ResultSet we parse
     * @return - Friendship Object - the friendship obtained
     * @throws Exception - if resultSet is null
     */
    private Friendship getFriendshipFromResult(ResultSet resultSet) throws Exception {
        String idFriend1 = resultSet.getString("idFriend1");
        String idFriend2 = resultSet.getString("idFriend2");
        LocalDate friendshipStartingDate = LocalDate.parse( resultSet.getString("friendshipdate"));
        LocalTime friendshipStartingTime = LocalTime.parse(resultSet.getString("friendshiptime"));
        LocalDateTime friendshipStartingMoment = LocalDateTime.of(friendshipStartingDate, friendshipStartingTime);
        boolean isPending = resultSet.getBoolean("isPending");
        boolean isFromFirstFriend = resultSet.getBoolean("isFromFirstFriend");
        return new Friendship(idFriend1, idFriend2, friendshipStartingMoment, isPending, isFromFirstFriend);
    }

    /**
     * Returns the friendship generated by the sqlQuery from database
     * @param sqlQuery - String
     * @return Friendship
     */
    private Friendship getFriendshipGeneratedByQuery(String sqlQuery){
        try(Connection connection = DriverManager.getConnection(this.url, this.username, this.password)){
            PreparedStatement statement = connection.prepareStatement(sqlQuery);
            ResultSet resultSet = statement.executeQuery();
            if(resultSet.next())
                return getFriendshipFromResult(resultSet);


        }catch (Exception e){
            throw new RuntimeException(e);
        }
        return null;
    }

    /**
     * Returns all friendships generated by the sqlQuery from database
     * @param sqlQuery - String
     * @return ArrayList<Friendship>
     */
    private ArrayList<Friendship> getAllFriendshipsGeneratedByQuery(String sqlQuery){
        ArrayList<Friendship> friendships = new ArrayList<>();
        try(Connection connection = DriverManager.getConnection(url, username, password)){
            PreparedStatement statement = connection.prepareStatement(sqlQuery);
            ResultSet resultSet = statement.executeQuery();

            while(resultSet.next())
                friendships.add(getFriendshipFromResult(resultSet));

            return friendships;

        }catch (Exception e){
            throw new RuntimeException(e.getMessage());
        }
    }


    /**
     * A method that execute a specific query on database, ignoring the result
     * @param sqlQuery - String
     */
    private void executeQuery(String sqlQuery){
        try(Connection connection = DriverManager.getConnection(this.url, this.username, this.password)){
            PreparedStatement statement = connection.prepareStatement(sqlQuery);
            statement.executeQuery();
        }catch (Exception e){
            if(!e.getMessage().contains("No results were returned by the query"))
                throw new RuntimeException(e);
        }
    }

    /**
     * Sorts the array of usernames
     * @param friendshipUsernames - the usernames
     */
    private static void sortArray(ArrayList<String> friendshipUsernames){
        friendshipUsernames.sort((string1, string2) -> {
            int minLength = min(string1.length(), string2.length());
            for(int i = 0 ; i < minLength ; i++){
                int chr1 = (int)string1.charAt(i);
                int chr2 = (int)string2.charAt(i);

                if(chr1 != chr2)
                    return chr1 - chr2;
            }
            return string1.length() - string2.length();
        });
    }

    /**
     * Returns the friendship from the users with chosen usernames. The order of the usernames doesn't matter
     * @param friendshipUsernames - must be not null
     * @return - Friendship - the wanted friendship
     */
    @Override
    public Friendship findById(ArrayList<String> friendshipUsernames) {
        sortArray(friendshipUsernames);
        String idFriend1 = friendshipUsernames.get(0);
        String idFriend2 = friendshipUsernames.get(1);
        String sqlQuery = "Select * from Friendships F where F.idFriend1 = '" + idFriend1 + "' and F.idFriend2= '"
                + idFriend2 + "'";
        return getFriendshipGeneratedByQuery(sqlQuery);
    }

    /**
     * Return an iterable of all friendships
     * @return - Iterable < Friendship >
     */
    @Override
    public Iterable<Friendship> findAll() {
        String sqlQuery = "Select * from Friendships";
        return getAllFriendshipsGeneratedByQuery(sqlQuery);
    }

    /**
     * A method that returns the query for inserting a new friendship in the database
     * @param friendship - Friendship
     * @return
     */
    private String prepareQueryForAddFriendship(Friendship friendship){
        ArrayList < String > friends = friendship.getId();
        sortArray(friends);
        String date = DataTypeConvertors.getDateStringFromDateTime(friendship.getFriendshipMoment());
        String time = DataTypeConvertors.getCompressedTimeStringFromDateTime(friendship.getFriendshipMoment());

        String sqlQuery = "Insert into Friendships values ('" + friends.get(0) + "','" + friends.get(1) + "','"
                + date + "','" + time + "'," + friendship.getIsPending() + "," + friendship.isFromFirstFriend() + ");";
        return sqlQuery;
    }

    /**
     * Add a new friendship in the database
     * @param entity - the entity we add
     * @return the existing friendship if the id is already taken and null otherwise
     */
    @Override
    public Friendship add(Friendship entity) {
        Friendship candidate = this.findById(entity.getId());
        if(candidate != null)
            return candidate;

        String sqlQuery = prepareQueryForAddFriendship(entity);
        executeQuery(sqlQuery);
        return null;
    }

    /**
     * Creates the string with sqlQuery that remove the friendship between users from friendshipUsers
     * @param friendshipUsers - the usernames of the users
     * @return String
     */
    private String prepareQueryForRemoveFriendship(ArrayList<String> friendshipUsers){
        ArrayList < String > friends = friendshipUsers;
        sortArray(friends);
        String sqlQuery = "DELETE FROM Friendships WHERE idFriend1 = '"  +
                        friends.get(0) + "' and idFriend2 = '" + friends.get(1) + "';";
        return sqlQuery;
    }

    /**
     * Remove the friendship with chosen id
     * @param friendshipId - ArrayList < String > - the id we want to delete
     * @return the friendship we removed from database
     */
    @Override
    public Friendship remove(ArrayList<String> friendshipId) {
        Friendship candidate = this.findById(friendshipId);
        if(candidate == null)
            throw new RuntimeException("There is no friendship with chosen index! ");
        String sqlQuery = prepareQueryForRemoveFriendship(friendshipId);
        executeQuery(sqlQuery);
        return candidate;
    }

    /**
     * Update the friendship with chosen id
     * @param id the id of the entity we update
     * @param friendship the new entity
     */
    @Override
    public void updateEntity(ArrayList<String> id, Friendship friendship) {
        this.remove(id);
        this.add(friendship);
    }

    /**
     * Check if an id is available in the database
     * @param candidateId - the id we check
     * @return - boolean - true or false
     */
    @Override
    public boolean availableId(ArrayList<String> candidateId) {
        return this.findById(candidateId) == null;
    }

    /**
     * Return the number of friendship from database
     * @return - int - number of friendships
     */
    @Override
    public int size() {
        String sqlQuery = "Select count(idFriend1) from Friendships";
        try(Connection connection = DriverManager.getConnection(url, username, password)){
            PreparedStatement statement = connection.prepareStatement(sqlQuery);

            ResultSet resultSet = statement.executeQuery();
            resultSet.next();
            return Integer.parseInt(resultSet.getString("count"));

        }catch (Exception e){
            throw new RuntimeException(e.getMessage());
        }
    }
}
